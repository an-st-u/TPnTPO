#include <iostream>
#include <cstdlib> // Для работы с функцией system()
#define MAX 2147483647.0
#define MIN -2147483648.0

using namespace std;


class Matrix{
	public:
		int M, N;
		float **A;
		Matrix(){ //по умолчанию
			M=N=0; A=NULL;
		}
		Matrix(int _m, int _n); // иниц
		Matrix(int _m, int _n, float* _A); //иниц
		Matrix(Matrix& V);//копии
		Matrix& operator-();
		Matrix& operator= (Matrix& V);
		Matrix& operator+(Matrix& V);
		Matrix& operator-(Matrix& V);
		Matrix& operator*(float x);
		~ Matrix ();
		
		friend ostream& operator<<(ostream& os, Matrix V);
		friend Matrix operator*(int t, const Matrix &V);
};

		// К-р инициализации
Matrix:: Matrix (int _m, int _n){
	M=_m;
	N=_n;
	//A = (float**) malloc(N*M*sizeof(float));
	A = (float **)malloc(M*sizeof(float*));
	// проверка выхода за диапазон
	for(int i = 0; i< M; i++){
		A[i] = (float *)malloc(N*sizeof(float));
	// проверка
	}
};

Matrix:: Matrix (int _m, int _n, float* _A){
	M=_m;
	N=_n;
	A = (float **)malloc(M*sizeof(float*));
	for(int i = 0; i< M; i++){
		A[i] = (float *)malloc(N*sizeof(float));
		for (int j=0;j<N;j++) {
			A[i][j]= A[i][j];
		}
	}
}

Matrix::~Matrix(){
	for(int i=0; i<M; i++)
		free(A[i]);
	free(A);
}


Matrix::Matrix (Matrix& V){ //выделение памяти
	M=V.M;
	N=V.N;
	A = (float **)malloc(M*sizeof(float*));
	// проверка
	for(int i = 0; i< M; i++){
		A[i] = (float *)malloc(N*sizeof(float));
		// проверка
	}
	for(int i=0; i<M; i++)
		for(int j=0; j<N; j++)
			A[i][j] = V.A[i][j];
};


Matrix& Matrix::operator-()
	{
			//float *buf = new float(M, N);
			Matrix *buf = new Matrix(M, N);
			float buff;
			for(int i = 0; i < M; ++i)
				for(int j = 0; j < N; ++j){
					buff = -A[i][j];
					buf->  A[i][j] = (float)buff;
				}
				return *buf;
	}

Matrix& Matrix::operator= (Matrix & V){
	if( M != V.M || N != V.N){
			cout<< "Error in dimensions";
			exit(1);
	}
	for(int i=0; i<M; i++)
		for(int j=0; j<N; j++)
			A[i][j] = V.A[i][j];
	return *this;
};

Matrix& Matrix::operator-(Matrix & V){
			Matrix *buf = new Matrix(M, N);
			float buff;
			for(int i = 0; i < M; ++i)
				for(int j = 0; j < N; ++j){
					buff = A[i][j] - V.A[i][j];
					buf->  A[i][j] = (float)buff;
				}
			return *buf;
	}

Matrix& Matrix::operator+(Matrix & V){ // сложение матриц
			Matrix *buf = new Matrix(M, N);
			float buff;
			for(int i = 0; i < M; ++i)
				for(int j = 0; j < N; ++j){
					buff = A[i][j] + V.A[i][j];
					buf->  A[i][j] = (float)buff;
				}
			return *buf;
	}

Matrix& Matrix::operator*(float t) // умножение матрицы на число A*2
	{
		if(M > 0 && N > 0 && A != NULL){
			Matrix *buf = new Matrix(M, N);
			double buff;
			for(int i = 0; i < M; ++i)
				for(int j = 0; j < N; ++j){
					buff = A[i][j] * t;
					buf->  A[i][j] = (float)buff;
				}
			return *buf;
		}
		else
			cout<< "sizeproblem *";
	}


Matrix operator*(int t, Matrix &V) // умножение числа на матрицу // бинарное умножение, тип 2*A друг класса
{
	if(V.M > 0 && V.N > 0 && V.A != NULL)
	{
		Matrix *buf = new Matrix(V.M, V.N);
		double buff;
		for(int i = 0; i < V.M; ++i)
			for(int j = 0; j < V.N; ++j)
			{
				buff = t * V.A[i][j];
				buf->  A[i][j] = (float)buff;
			}
		return *buf;
	}
	else
	{
		cout<< "sizeproblem *";
		exit(1);
		return V;
	}
}

ostream& operator<<(ostream &os, Matrix V)
{
	for(int i = 0; i < V.M; ++i)
		os<<V.A[i];
	return os;
}



int  main()
{
	float x[][4]={{3, 5, 2, 6}, {3, 5, 2, 6}};
	float y[][4]={{1, 1, 1, 1}, {0, 0, 0, 0}};
	Matrix A(2, 4, (float*)x), B(2, 4, (float*)y);
	Matrix C(2, 4);
	C = -A+2*A-A+B*2;
	//C[0][0] = 100;
	//[6][0] = 1; //ошибка!!
	//cout << F << endl;
	/*использование класса вектора
	//float z[]={0, 0, 0, 1};
	//Vector D(sizeof(z), z), R(2);
	//R=A*D;
	cout << R;*/
	system("pause");
    return 0;
}
